var Hangul = (function (exports) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var consonants={ㄱ:1,ㄴ:1,ㄷ:1,ㄹ:1,ㅁ:1,ㅂ:1,ㅅ:1,ㅇ:1,ㅈ:1,ㅊ:1,ㅋ:1,ㅌ:1,ㅍ:1,ㅎ:1,ㆁ:1,// apparently this is now "ㅇ"
  ㆄ:1,ㅱ:1,ㅿ:1};var vowels={ㅏ:1,ㅐ:1,ㅑ:1,ㅓ:1,ㅔ:1,ㅕ:1,ㅖ:1,ㅗ:1,ㅛ:1,ㅜ:1,ㅠ:1,ㅡ:1,ㅣ:1,ㆍ:1};var hangulToKey={ㅂ:"q",ㅃ:"Q",ㅈ:"w",ㅉ:"W",ㄷ:"e",ㄸ:"E",ㄱ:"r",ㄲ:"R",ㅅ:"t",ㅆ:"T",ㅛ:"y",ㅕ:"u",ㅑ:"i",ㅐ:"o",ㅒ:"O",ㅔ:"p",ㅖ:"P",ㅁ:"a",ㄴ:"s",ㅇ:"d",ㄹ:"f",ㅎ:"g",ㅗ:"h",ㅓ:"j",ㅏ:"k",ㅣ:"l",ㅋ:"z",ㅌ:"x",ㅊ:"c",ㅍ:"v",ㅠ:"b",ㅜ:"n",ㅡ:"m"};var keyToHangul={q:"\u3142",Q:"\u3143",w:"\u3148",W:"\u3149",e:"\u3137",E:"\u3138",r:"\u3131",R:"\u3132",t:"\u3145",T:"\u3146",y:"\u315B",u:"\u3155",i:"\u3151",o:"\u3150",O:"\u3152",p:"\u3154",P:"\u3156",a:"\u3141",s:"\u3134",d:"\u3147",f:"\u3139",g:"\u314E",h:"\u3157",j:"\u3153",k:"\u314F",l:"\u3163",z:"\u314B",x:"\u314C",c:"\u314A",v:"\u314D",b:"\u3160",n:"\u315C",m:"\u3161"};// the reason the data is stored like this is because iterating
  // through an array is slower than just getting a key from an object
  // In this case though, it might be faster since arrays are allocated
  // on the heap instead of the stack?
  // I realize that I can programmatically reverse the key-value pairs during
  // runtime but since I can just do it now, it's just a little faster.

  var cho={ㄱㄱ:"\u3132",ㄷㄷ:"\u3138",ㅅㅅ:"\u3146",ㅈㅈ:"\u3149",ㅂㅂ:"\u3143"};var jung={ㅗㅏ:"\u3158",ㅗㅐ:"\u3159",ㅗㅣ:"\u315A",ㅜㅓ:"\u315D",ㅜㅔ:"\u315E",ㅜㅣ:"\u315F",ㅡㅣ:"\u3162"};var jong={ㄱㄱ:"\u3132",ㄱㅅ:"\u3133",ㄴㅈ:"\u3135",ㄴㅎ:"\u3136",ㄹㄱ:"\u313A",ㄹㅁ:"\u313B",ㄹㅂ:"\u313C",ㄹㅅ:"\u313D",ㄹㅌ:"\u313E",ㄹㅍ:"\u313F",ㄹㅎ:"\u3140",ㅂㅅ:"\u3144",ㅅㅅ:"\u3146"};var archaic={ㄴㄴ:"\u3165",ㄴㄷ:"\u3166",ㄴㅅ:"\u3167",ㄴㅿ:"\u3168",ㄹㄱㅅ:"\u3169",ㄹㄷ:"\u316A",ㄹㅂㅅ:"\u316B",ㄹㅿ:"\u316C",ㄹㆆ:"\u316D",ㅁㅂ:"\u316E",ㅁㅅ:"\u316F",ㅁㅿ:"\u3170",ㅂㄱ:"\u3172",ㅂㄷ:"\u3173",ㅂㅅㄱ:"\u3174",ㅂㅅㄷ:"\u3175",ㅂㅈ:"\u3176",ㅂㅌ:"\u3177",ㅅㄱ:"\u317A",ㅅㄴ:"\u317B",ㅅㄷ:"\u317C",ㅅㅂ:"\u317D",ㅅㅈ:"\u317E",ㅇㅇ:"\u3180",ㆁㅅ:"\u3181",ㆁㅿ:"\u317F",ㅎㅎ:"\u3185",ㅛㅑ:"\u3187",ㅛㅒ:"\u3188",ㅛㅣ:"\u3189",ㅠㅕ:"\u318A",ㅠㅖ:"\u318B",ㅠㅣ:"\u318C",ㆍㅣ:"\u318E"};var pairs={ㄲ:["\u3131","\u3131"],ㄳ:["\u3131","\u3145"],ㄵ:["\u3134","\u3148"],ㄶ:["\u3134","\u314E"],ㄸ:["\u3137","\u3137"],ㄻ:["\u3139","\u3141"],ㄺ:["\u3139","\u3131"],ㄼ:["\u3139","\u3142"],ㄽ:["\u3139","\u3145"],ㄾ:["\u3139","\u314C"],ㄿ:["\u3139","\u314D"],ㅀ:["\u3139","\u314E"],ㅃ:["\u3142","\u3142"],ㅄ:["\u3142","\u3145"],ㅆ:["\u3145","\u3145"],ㅉ:["\u3148","\u3148"],ㅘ:["\u3157","\u314F"],ㅙ:["\u3157","\u3150"],ㅚ:["\u3157","\u3163"],ㅝ:["\u315C","\u3153"],ㅞ:["\u315C","\u3154"],ㅟ:["\u315C","\u3163"],ㅢ:["\u3161","\u3163"],ㅥ:["\u3134","\u3134"],ㅦ:["\u3134","\u3137"],ㅧ:["\u3134","\u3145"],ㅨ:["\u3134","\u317F"],ㅩ:["\u3139","\u3131","\u3145"],ㅪ:["\u3139","\u3137"],ㅫ:["\u3139","\u3142","\u3145"],ㅬ:["\u3139","\u317F"],ㅭ:["\u3139","\u3186"],ㅮ:["\u3141","\u3142"],ㅯ:["\u3141","\u3145"],ㅰ:["\u3141","\u317F"],ㅲ:["\u3142","\u3131"],ㅳ:["\u3142","\u3137"],ㅴ:["\u3142","\u3145","\u3131"],ㅵ:["\u3142","\u3145","\u3137"],ㅶ:["\u3142","\u3148"],ㅷ:["\u3142","\u314C"],ㅺ:["\u3145","\u3131"],ㅻ:["\u3145","\u3134"],ㅼ:["\u3145","\u3137"],ㅽ:["\u3145","\u3142"],ㅾ:["\u3145","\u3148"],ㆀ:["\u3147","\u3147"],ㆂ:["\u3181","\u3145"],ㆃ:["\u3181","\u317F"],ㆅ:["\u314E","\u314E"],ㆇ:["\u315B","\u3151"],ㆈ:["\u315B","\u3152"],ㆉ:["\u315B","\u3163"],ㆊ:["\u3160","\u3155"],ㆋ:["\u3160","\u3156"],ㆌ:["\u3160","\u3163"],ㆎ:["\u318D","\u3163"]};var complex={ㄲ:1,ㄳ:1,ㄵ:1,ㄶ:1,ㄸ:1,ㄺ:1,ㄻ:1,ㄼ:1,ㄽ:1,ㄾ:1,ㄿ:1,ㅀ:1,ㅃ:1,ㅄ:1,ㅆ:1,ㅉ:1,ㅘ:1,ㅙ:1,ㅚ:1,ㅝ:1,ㅞ:1,ㅟ:1,ㅢ:1};var irregularComplex={ㅥ:1,ㅦ:1,ㅧ:1,ㅨ:1,ㅩ:1,ㅪ:1,ㅫ:1,ㅬ:1,ㅭ:1,ㅮ:1,ㅯ:1,ㅰ:1,ㅱ:1,ㅲ:1,ㅳ:1,ㅴ:1,ㅵ:1,ㅶ:1,ㅷ:1};var complexList=Object.assign({},complex,irregularComplex);// yes, I know that this is not a list.
  var stronger={ㄱ:"\u3132",ㅋ:"\u3132",ㄷ:"\u3138",ㅌ:"\u3138",ㅂ:"\u3143",ㅍ:"\u3143",ㅅ:"\u3146",ㅈ:"\u3149",ㅊ:"\u3149"};// I would add a weaker export
  // except that I can't reverse the outputs

  var cho$1=["\u3131","\u3132","\u3134","\u3137","\u3138","\u3139","\u3141","\u3142","\u3143","\u3145","\u3146","\u3147","\u3148","\u3149","\u314A","\u314B","\u314C","\u314D","\u314E"];var jung$1=["\u314F","\u3150","\u3151","\u3152","\u3153","\u3154","\u3155","\u3156","\u3157","\u3158","\u3159","\u315A","\u315B","\u315C","\u315D","\u315E","\u315F","\u3160","\u3161","\u3162","\u3163"];var jong$1=[null,"\u3131","\u3132","\u3133","\u3134","\u3135","\u3136","\u3137","\u3139","\u313A","\u313B","\u313C","\u313D","\u313E","\u313F","\u3140","\u3141","\u3142","\u3144","\u3145","\u3146","\u3147","\u3148","\u314A","\u314B","\u314C","\u314D","\u314E"];var choNum={ㄱ:0,ㄲ:1,ㄴ:2,ㄷ:3,ㄸ:4,ㄹ:5,ㅁ:6,ㅂ:7,ㅃ:8,ㅅ:9,ㅆ:10,ㅇ:11,ㅈ:12,ㅉ:13,ㅊ:14,ㅋ:15,ㅌ:16,ㅍ:17,ㅎ:18};var jungNum={ㅏ:0,ㅐ:1,ㅑ:2,ㅒ:3,ㅓ:4,ㅔ:5,ㅕ:6,ㅖ:7,ㅗ:8,ㅘ:9,ㅙ:10,ㅚ:11,ㅛ:12,ㅜ:13,ㅝ:14,ㅞ:15,ㅟ:16,ㅠ:17,ㅡ:18,ㅢ:19,ㅣ:20};var jongNum={ㄱ:1,ㄲ:2,ㄳ:3,ㄴ:4,ㄵ:5,ㄶ:6,ㄷ:7,ㄹ:8,ㄺ:9,ㄻ:10,ㄼ:11,ㄽ:12,ㄾ:13,ㄿ:14,ㅀ:15,ㅁ:16,ㅂ:17,ㅄ:18,ㅅ:19,ㅆ:20,ㅇ:21,ㅈ:22,ㅊ:23,ㅋ:24,ㅌ:25,ㅍ:26,ㅎ:27};

  var UnicodeRange=/*#__PURE__*/function(){function a(b,c){_classCallCheck(this,a),this.start=b,this.end=c;}return _createClass(a,[{key:"containsCodePoint",value:function containsCodePoint(a){return a>=this.start&&a<=this.end}},{key:"contains",value:function contains(a){return this.containsCodePoint(a.codePointAt(0))}}]),a}();var CombinedRange=/*#__PURE__*/function(){function a(b){var c=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,a),this.ranges=b,this.codePoints=c;}return _createClass(a,[{key:"containsCodePoint",value:function containsCodePoint(a){return this.codePoints&&this.codePoints[a]||this.ranges.some(function(b){return b.containsCodePoint(a)})}},{key:"contains",value:function contains(a){var b=a.codePointAt(0);return this.containsCodePoint(b)}}]),a}();

  var jamo=new UnicodeRange(4352,4607);var compatibilityJamo=new UnicodeRange(12592,12687);var jamoExtendedA=new UnicodeRange(43360,43391);var syllables=new UnicodeRange(44032,55215);var jamoExtendedB=new UnicodeRange(55216,55295);var halfwidth=new UnicodeRange(65440,65503);var reserved=new CombinedRange([new UnicodeRange(43389,43391),// jamoExtendedA
  new UnicodeRange(55204,55215),// syllables
  new UnicodeRange(55239,55242),// jamoExtendedB
  new UnicodeRange(55292,55295)],{12592:1,12687:1});var standardHangul=new CombinedRange([compatibilityJamo,syllables]);var hangul=new CombinedRange([jamo,compatibilityJamo,jamoExtendedA,syllables,jamoExtendedB,halfwidth,reserved]);

  var blocks = /*#__PURE__*/Object.freeze({
    jamo: jamo,
    compatibilityJamo: compatibilityJamo,
    jamoExtendedA: jamoExtendedA,
    syllables: syllables,
    jamoExtendedB: jamoExtendedB,
    halfwidth: halfwidth,
    reserved: reserved,
    standardHangul: standardHangul,
    hangul: hangul
  });

  var composeSyllableFn = (function(a,b){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:0;return String.fromCodePoint(588*a+28*b+c+syllables.start)// this is the actual function that makes unicode syllable characters
  // where the characters are mapped to numbers. Take a look at
  // { choNum, jungNum, jongNum } from './unicode/syllable'
  });

  var Result=function a(){var b=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"",c=1<arguments.length&&arguments[1]!==void 0?arguments[1]:[];_classCallCheck(this,a),this.result=b,this.remainder=c;};

  var Character=function(a){var b="".concat(a);// not using .toString because Symbol.toPrimitive overrides when present
  if(1!==b.length)throw Error("\"".concat(b,"\" is not a Character!"));return b};// this function turns values into characters if it can
  // otherwise it just fails
  var ENOARYLIKE=function(){throw TypeError("The data must be an Array or a String!")};var toArray=function(a){return Array.isArray(a)?a:a.split("")};// as a general note, calling .split like that instead of .split`` is faster
  var isCharacterGroup=function(a){return !(1>a.length)&&(Array.isArray(a)?!!(1<a.length)||isCharacterGroup(a[0]):!!("string"==typeof a&&1<a.length))};// while Characters can be a CharacterGroup,
  // this function ignores characters
  var identity=function(a){return a};var deepMap=function(a,b,c){var d=c?toArray:identity;return Array.isArray(a)?a.map(function(a){return isCharacterGroup(a)?deepMap(a,b,c):d(b(a))}):"string"==typeof a?a.split("").map(function(a){return d(b(a))}):void ENOARYLIKE()};var deepFlatMap=function(a,b){var c="";if(Array.isArray(a)){for(var d,e=a.length,f=0;f<e;f++)if(d=a[f],isCharacterGroup(d))c+=deepFlatMap(d,b);else{var k=b(d);c+=isCharacterGroup(k)?deepFlatMap(k,identity):k;}}else if("string"==typeof a)for(var g,h=a.length,j=0;j<h;j++)g=b(a[j]),c+=isCharacterGroup(g)?deepFlatMap(g,identity):g;else ENOARYLIKE();return c};var flatten=function(a){if(Array.isArray(a)){for(var b,c="",d=a.length,e=0;e<d;e++)b=a[e],c+=isCharacterGroup(b)?flatten(b):b;return c}return "string"==typeof a?a:void ENOARYLIKE()};var deepFlatResMap=function(a,b){// this is different since it deals with functions that return Result objects.
  // consumeLeftovers
  var c,d="";// remaining
  // result
  if(Array.isArray(a)){c=[];for(var e,f=a.length,g=0;g<f;g++)if(e=a[g],isCharacterGroup(e)){var h;(h=c).push.apply(h,_toConsumableArray(deepFlatResMap(e,b)));}else c.push(e);}else"string"==typeof a?c=a.split(""):ENOARYLIKE();for(;c.length;){var j=b(c);// func needs to return a Result like interface for this to work
  // otherwise we'll get a really nasty to debug error
  d+=j.result,c=j.remainder;}return d};

  var useArchaic=2;// allows operation on archaic complex characters such as "ㅨ"
  var useComp3=4;// allows operation on complex characters composed of three base characters.
  // this means you can make things like "ㅩ", "ㅫ", "ㅴ", and "ㅵ".
  var noJungJong=8;// disallows operation on complex jung and complex jong
  // useful for only composing complex cho
  var noDouble=16;// disallows operation on two of the same character
  // both useArchaic and useComp3

  // these functions aren't going to really make any sense until
  // you understand how they work in conjunction with the stuff
  // that's in './types'. Read './Result' and './types' first.
  // then read this.
  var objCache=[],composeComplexBase=function(a){// mode is being used as a bitfield
  if(0>a||31<a)throw Error("The mode cannot be less than zero or greater than 31 (0b11111)!");var b=a&useArchaic,c=objCache[a];if(!c){var d=[cho];// there are no comp3 values in non archaic complex objects
  a&noJungJong||d.push(jung,jong),b&&d.push(archaic),c=Object.assign.apply(Object,[{}].concat(d)),objCache[a]=c;}return function(d){var e=d.length;if(1>e)throw Error("Cannot compose array of zero characters!");var f=d[0];if(2>e)// if there aren't even two Characters to use
  return new Result(f);var g=d[1];if(a&noDouble&&f===g)return new Result(f,d.slice(1));var h=c[f+g];// comp2 = composition of 2 characters
  if(h){if(b&&a&useComp3&&2<e){// if there's more data, try to compose a tripple
  var i=c[f+g+d[2]];if(i)return new Result(i,d.slice(3))}// there's no more data or couldn't find a comp3
  return new Result(h,d.slice(2))}// couldn't find a comp2
  return new Result(f,d.slice(1))}};var composeComplex=function(a){var b=composeComplexBase(a);return function(a){return deepFlatResMap(a,b)}};var isVowel=function(a){return a&&"\u318D"!==a&&vowels[a]};var composeAnything = (function(a){var b=composeComplexBase(a);return function(a){var c=Number.isInteger;// while this function is named "composeSyllable", it actually
  // can be used to compose anything, really.
  if(2>a.length)return new Result(a[0]);// don't do extra computing for small operations
  // the composeComplex function with the mode that is specified
  var d=b(a),e=d.result,f=d.remainder,g=choNum[e];// ^^ that's a Result object
  // the number that the character is mapped to
  if(1>f.length||!c(g))// check if there's any more characters remaining
  // also check if it's not an integer since 0 == false
  // if it's not an integer, then return the potential
  // complex or Character that was made from composeAnyComplex
  return d;// choRes is already a Result so no need to make another
  var h=b(f),i=h.result,j=h.remainder,k=jungNum[i];if(!c(k))// there's no need to check to see if there's any more
  // remaining since cho and jung are all that's needed
  // to compose a syllable
  return new Result(e,[i].concat(_toConsumableArray(j)));// still only return choChar as a result since we want
  // to try starting a syllable off with the jungChar next
  // time this function is called
  if(j.length&&!isVowel(j[1]))// there's no point in trying to add anything on to the complex
  // if there aren't any characters left
  {// we need this part so that
  // ㅁㅣㅇㅏ => 미아
  var l=b(j),m=l.result,n=l.remainder,o=jongNum[m];if(o)// if the character after the syllable is not a vowel
  // and the jong character is valid
  return new Result(composeSyllableFn(g,k,o),n)}// there aren't any characters left
  // or the character after the syllable is a vowel
  // or the jong character isn't valid
  return new Result(composeSyllableFn(g,k),j);// The last argument is optional for the Result constructor
  }});

  // if you're gonna copy this part, at least give me credit.
  // I had to do all of this manually.
  // also, I think turning all of these arrays into strings
  // might speed up composition by a bit.
  var jamo$1={ᄀ:"\u3131",ᄁ:["\u3131","\u3131"],ᄂ:"\u3134",ᄃ:"\u3137",ᄄ:["\u3137","\u3137"],ᄅ:"\u3139",ᄆ:"\u3141",ᄇ:"\u3142",ᄈ:["\u3142","\u3142"],ᄉ:"\u3145",ᄊ:["\u3145","\u3145"],ᄋ:"\u3147",ᄌ:"\u3148",ᄍ:["\u3148","\u3148"],ᄎ:"\u314A",ᄏ:"\u314B",ᄐ:"\u314C",ᄑ:"\u314D",ᄒ:"\u314E",ᄓ:["\u3134","\u3131"],ᄔ:["\u3134","\u3134"],ᄕ:["\u3134","\u3137"],ᄖ:["\u3134","\u3142"],ᄗ:["\u3137","\u3131"],ᄘ:["\u3139","\u3134"],ᄙ:["\u3139","\u3139"],ᄚ:["\u3139","\u314E"],ᄛ:["\u3139","\u3147"],ᄜ:["\u3141","\u3142"],ᄝ:"\u3171",ᄞ:["\u3142","\u3131"],ᄟ:["\u3142","\u3134"],ᄠ:["\u3142","\u3137"],ᄡ:["\u3142","\u3145"],ᄢ:["\u3142","\u3145","\u3131"],ᄣ:["\u3142","\u3145","\u3137"],ᄤ:["\u3142","\u3145","\u3142"],ᄥ:["\u3142","\u3145","\u3145"],ᄦ:["\u3142","\u3145","\u3148"],ᄧ:["\u3142","\u3148"],ᄨ:["\u3142","\u314A"],ᄩ:["\u3142","\u314C"],ᄪ:["\u3142","\u314D"],ᄫ:["\u3142","\u3147"],ᄬ:[["\u3142","\u3142"],"\u3147"],ᄭ:["\u3145","\u3131"],ᄮ:["\u3145","\u3134"],ᄯ:["\u3145","\u3137"],ᄰ:["\u3145","\u3139"],ᄱ:["\u3145","\u3141"],ᄲ:["\u3145","\u3142"],ᄳ:["\u3145","\u3142","\u3131"],ᄴ:["\u3145","\u3145","\u3145"],ᄵ:["\u3145","\u3147"],ᄶ:["\u3145","\u3148"],ᄷ:["\u3145","\u314A"],ᄸ:["\u3145","\u314B"],ᄹ:["\u3145","\u314C"],ᄺ:["\u3145","\u314D"],ᄻ:["\u3145","\u314E"],ᄼ:null,ᄽ:null,ᄾ:null,ᄿ:null,ᅀ:"\u317F",ᅁ:["\u3147","\u3131"],ᅂ:["\u3147","\u3137"],ᅃ:["\u3147","\u3141"],ᅄ:["\u3147","\u3142"],ᅅ:["\u3147","\u3145"],ᅆ:["\u3147","\u317F"],ᅇ:["\u3147","\u3147"],ᅈ:["\u3147","\u3148"],ᅉ:["\u3147","\u314A"],ᅊ:["\u3147","\u314C"],ᅋ:["\u3147","\u314D"],ᅌ:"\u3181",ᅍ:["\u3148","\u3147"],ᅎ:null,ᅏ:null,ᅐ:null,ᅑ:null,ᅒ:["\u314A","\u314B"],ᅓ:["\u314A","\u314E"],ᅔ:null,ᅕ:null,ᅖ:["\u314D","\u3142"],ᅗ:"\u3184",ᅘ:["\u314E","\u314E"],ᅙ:"\u3186",ᅚ:["\u3131","\u3137"],ᅛ:["\u3131","\u3145"],ᅜ:["\u3131","\u3148"],ᅝ:["\u3131","\u314E"],ᅞ:["\u3137","\u3139"],ᅡ:"\u314F",ᅢ:"\u3150",ᅣ:"\u3151",ᅤ:"\u3152",ᅥ:"\u3153",ᅦ:"\u3154",ᅧ:"\u3155",ᅨ:"\u3156",ᅩ:"\u3157",ᅪ:["\u3157","\u314F"],ᅫ:["\u3157","\u3150"],ᅬ:["\u3157","\u3163"],ᅭ:"\u315B",ᅮ:"\u315C",ᅯ:["\u315C","\u3153"],ᅰ:["\u315C","\u3154"],ᅱ:["\u315C","\u3163"],ᅲ:"\u3160",ᅳ:"\u3161",ᅴ:["\u3161","\u3163"],ᅵ:"\u3163",ᅶ:["\u314F","\u3157"],ᅷ:["\u314F","\u315C"],ᅸ:["\u3151","\u3157"],ᅹ:["\u3151","\u315B"],ᅺ:["\u3153","\u3157"],ᅻ:["\u3153","\u315C"],ᅼ:["\u3153","\u3161"],ᅽ:["\u3155","\u3157"],ᅾ:["\u3155","\u315C"],ᅿ:["\u3157","\u3153"],ᆀ:["\u3154","\u3157"],ᆁ:["\u3156","\u3157"],ᆂ:["\u3157","\u3157"],ᆃ:["\u3157","\u315C"],ᆄ:["\u315B","\u3151"],ᆅ:["\u315B","\u3152"],ᆆ:["\u315B","\u3155"],ᆇ:["\u315B","\u3157"],ᆈ:["\u315B","\u3163"],ᆉ:["\u315C","\u314F"],ᆊ:["\u315C","\u3150"],ᆋ:["\u315C","\u3153","\u3161"],ᆌ:["\u315C","\u3156"],ᆍ:["\u315C","\u315C"],ᆎ:["\u3160","\u314F"],ᆏ:["\u3160","\u3153"],ᆐ:["\u3160","\u3154"],ᆑ:["\u3160","\u3155"],ᆒ:["\u3160","\u3154"],ᆓ:["\u3160","\u315C"],ᆔ:["\u3160","\u3163"],ᆕ:["\u3161","\u315C"],ᆖ:["\u3161","\u3161"],ᆗ:["\u3161","\u3163","\u315C"],ᆘ:["\u3163","\u314F"],ᆙ:["\u3163","\u3151"],ᆚ:["\u3163","\u3157"],ᆛ:["\u3163","\u315C"],ᆜ:["\u3163","\u3161"],ᆝ:null,ᆞ:"\u318D",ᆟ:["\u318D","\u3153"],ᆠ:["\u318D","\u315C"],ᆡ:["\u318D","\u3163"],ᆢ:["\u318D","\u318D"],ᆣ:["\u314F","\u3161"],ᆤ:["\u3151","\u315C"],ᆥ:["\u3155","\u3151"],ᆦ:["\u3157","\u3151"],ᆧ:["\u3157","\u3152"],ᆨ:"\u3131",ᆩ:["\u3131","\u3131"],ᆪ:["\u3131","\u3145"],ᆫ:"\u3134",ᆬ:["\u3134","\u3148"],ᆭ:["\u3134","\u314E"],ᆮ:"\u3137",ᆯ:"\u3139",ᆰ:["\u3139","\u3131"],ᆱ:["\u3139","\u3141"],ᆲ:["\u3139","\u3142"],ᆳ:["\u3139","\u3145"],ᆴ:["\u3139","\u314C"],ᆵ:["\u3139","\u314D"],ᆶ:["\u3139","\u314E"],ᆷ:"\u3141",ᆸ:"\u3142",ᆹ:["\u3142","\u3145"],ᆺ:"\u3145",ᆻ:["\u3145","\u3145"],ᆼ:"\u3147",ᆽ:"\u3148",ᆾ:"\u314A",ᆿ:"\u314B",ᇀ:"\u314C",ᇁ:"\u314D",ᇂ:"\u314E",ᇃ:["\u3131","\u3139"],ᇄ:["\u3131","\u3145","\u3131"],ᇅ:["\u3134","\u3131"],ᇆ:["\u3134","\u3137"],ᇇ:["\u3134","\u3145"],ᇈ:["\u3134","\u317F"],ᇉ:["\u3134","\u314C"],ᇊ:["\u3137","\u3131"],ᇋ:["\u3137","\u3139"],ᇌ:["\u3139","\u3131","\u3145"],ᇍ:["\u3139","\u3134"],ᇎ:["\u3139","\u3137"],ᇏ:["\u3139","\u3137","\u314E"],ᇐ:["\u3139","\u3139"],ᇑ:["\u3139","\u3141","\u3131"],ᇒ:["\u3139","\u3141","\u3145"],ᇓ:["\u3139","\u3142","\u3145"],ᇔ:["\u3139","\u3142","\u314E"],ᇕ:["\u3139","\u3178"],ᇖ:["\u3139","\u3145","\u3145"],ᇗ:["\u3139","\u317F"],ᇘ:["\u3139","\u314B"],ᇙ:["\u3139","\u3186"],ᇚ:["\u3141","\u3131"],ᇛ:["\u3141","\u3139"],ᇜ:["\u3141","\u3142"],ᇝ:["\u3141","\u3145"],ᇞ:["\u3141","\u3145","\u3145"],ᇟ:["\u3141","\u317F"],ᇠ:["\u3141","\u314A"],ᇡ:["\u3141","\u314E"],ᇢ:"\u3171",ᇣ:["\u3142","\u3139"],ᇤ:["\u3142","\u314D"],ᇥ:["\u3142","\u314E"],ᇦ:["\u3142","\u3147"],ᇧ:["\u3145","\u3131"],ᇨ:["\u3145","\u3137"],ᇩ:["\u3145","\u3139"],ᇪ:["\u3145","\u3142"],ᇫ:"\u317F",ᇬ:["\u3181","\u3131"],ᇭ:["\u3181","\u3131","\u3131"],ᇮ:["\u3181","\u3181"],ᇯ:["\u3181","\u314B"],ᇰ:"\u3181",ᇱ:["\u3181","\u3145"],ᇲ:["\u3181","\u317F"],ᇳ:["\u314D","\u3142"],ᇴ:"\u3184",ᇵ:["\u314E","\u3134"],ᇶ:["\u314E","\u3139"],ᇷ:["\u314E","\u3141"],ᇸ:["\u314E","\u3142"],ᇹ:"\u3186",ᇺ:["\u3131","\u3134"],ᇻ:["\u3131","\u3142"],ᇼ:["\u3131","\u314A"],ᇽ:["\u3131","\u314B"],ᇾ:["\u3131","\u314E"],ᇿ:["\u3134","\u3134"]};var jamoExtendedA$1={ꥠ:["\u3137","\u3141"],ꥡ:["\u3137","\u3142"],ꥢ:["\u3137","\u3145"],ꥣ:["\u3137","\u3148"],ꥤ:["\u3139","\u3131"],ꥥ:["\u3139","\u3131","\u3131"],ꥦ:["\u3139","\u3137"],ꥧ:["\u3139","\u3137","\u3137"],ꥨ:["\u3139","\u3141"],ꥩ:["\u3139","\u3142"],ꥪ:["\u3139","\u3142","\u3142"],ꥫ:["\u3139","\u3178"],ꥬ:["\u3139","\u3145"],ꥭ:["\u3139","\u3148"],ꥮ:["\u3139","\u314B"],ꥯ:["\u3141","\u3131"],ꥰ:["\u3141","\u3137"],ꥱ:["\u3141","\u3145"],ꥲ:["\u3142","\u3145","\u314C"],ꥳ:["\u3142","\u314B"],ꥴ:["\u3142","\u314E"],ꥵ:["\u3145","\u3145","\u3142"],ꥶ:["\u3147","\u3139"],ꥷ:["\u3147","\u314E"],ꥸ:["\u3148","\u3148","\u314E"],ꥹ:["\u314C","\u314C"],ꥺ:["\u314D","\u314E"],ꥻ:["\u314E","\u3145"],ꥼ:["\u3186","\u3186"]};var jamoExtendedB$1={ힰ:["\u3157","\u3155"],ힱ:["\u3157","\u3157","\u3163"],ힲ:["\u315B","\u314F"],ힳ:["\u315B","\u3150"],ힴ:["\u315B","\u3153"],ힵ:["\u315C","\u3155"],ힶ:["\u315C","\u3163","\u3163"],ힷ:["\u3160","\u3150"],ힸ:["\u3160","\u3157"],ힹ:["\u3161","\u314F"],ힺ:["\u3161","\u3153"],ힻ:["\u3161","\u3154"],ힼ:["\u3161","\u3157"],ힽ:["\u3163","\u314F","\u3157"],ힾ:["\u3163","\u3152"],ힿ:["\u3163","\u3155"],ퟀ:["\u3163","\u3156"],ퟁ:["\u3163","\u3157","\u3163"],ퟂ:["\u3163","\u315B"],ퟃ:["\u3163","\u3160"],ퟄ:["\u3163","\u3163"],ퟅ:["\u318D","\u314F"],ퟆ:["\u318D","\u3154"],ퟋ:["\u3134","\u3139"],ퟌ:["\u3134","\u3148"],ퟍ:["\u3137","\u3137"],ퟎ:["\u3137","\u3137","\u3142"],ퟏ:["\u3137","\u3142"],ퟐ:["\u3137","\u3145"],ퟑ:["\u3137","\u3145","\u3131"],ퟒ:["\u3137","\u3148"],ퟓ:["\u3137","\u314A"],ퟔ:["\u3137","\u314C"],ퟕ:["\u3139","\u3131","\u3131"],ퟖ:["\u3139","\u3131","\u314E"],ퟗ:["\u3139","\u3139","\u314B"],ퟘ:["\u3139","\u3141","\u314E"],ퟙ:["\u3139","\u3142","\u3137"],ퟚ:["\u3139","\u3142","\u314D"],ퟛ:["\u3139","\u3181"],ퟜ:["\u3139","\u3186","\u314E"],ퟝ:null,ퟞ:["\u3141","\u3134"],ퟟ:["\u3141","\u3134","\u3134"],ퟠ:["\u3141","\u3141"],ퟡ:["\u3141","\u3142","\u3145"],ퟢ:["\u3141","\u3148"],ퟣ:["\u3142","\u3137"],ퟤ:["\u3142","\u3139","\u314D"],ퟥ:["\u3142","\u3141"],ퟦ:["\u3142","\u3142"],ퟧ:["\u3142","\u3145","\u3137"],ퟨ:["\u3142","\u3148"],ퟩ:["\u3142","\u314A"],ퟪ:["\u3145","\u3141"],ퟫ:["\u3145","\u3178"],ퟬ:["\u3145","\u3145","\u3131"],ퟭ:["\u3145","\u3145","\u3137"],ퟮ:["\u3145","\u317F"],ퟯ:["\u3145","\u3148"],ퟰ:["\u3145","\u314A"],ퟱ:["\u3145","\u314C"],ퟲ:["\u3145","\u314E"],ퟳ:["\u317F","\u3142"],ퟴ:["\u317F","\u3178"],ퟵ:["\u3181","\u3141"],ퟶ:["\u3181","\u314E"],ퟷ:["\u3148","\u3142"],ퟸ:["\u3148","\u3142","\u3142"],ퟹ:["\u3148","\u3148"],ퟺ:["\u314D","\u3145"],ퟻ:["\u314D","\u314C"]};var halfwidth$1={ﾡ:"\u3131",ﾢ:["\u3131","\u3131"],ﾣ:["\u3131","\u3145"],ﾤ:"\u3134",ﾥ:["\u3134","\u3148"],ﾦ:["\u3134","\u314E"],ﾧ:"\u3137",ﾨ:["\u3137","\u3137"],ﾩ:"\u3139",ﾪ:["\u3139","\u3131"],ﾫ:["\u3139","\u3141"],ﾬ:["\u3139","\u3142"],ﾭ:["\u3139","\u3145"],ﾮ:["\u3139","\u314C"],ﾯ:["\u3139","\u314D"],ﾰ:["\u3139","\u314E"],ﾱ:"\u3141",ﾲ:"\u3142",ﾳ:["\u3142","\u3142"],ﾴ:["\u3142","\u3145"],ﾵ:"\u3145",ﾶ:["\u3145","\u3145"],ﾷ:"\u3147",ﾸ:"\u3148",ﾹ:["\u3148","\u3148"],ﾺ:"\u314A",ﾻ:"\u314B",ﾼ:"\u314C",ﾽ:"\u314D",ﾾ:"\u314E",ￂ:"\u314F",ￃ:"\u3150",ￄ:"\u3151",ￅ:"\u3152",ￆ:"\u3153",ￇ:"\u3154",ￊ:"\u3155",ￋ:"\u3156",ￌ:"\u3157",ￍ:["\u3157","\u314F"],ￎ:["\u3157","\u3150"],ￏ:["\u3157","\u3163"],ￒ:"\u315B",ￓ:"\u315C",ￔ:["\u315C","\u3153"],ￕ:["\u315C","\u3154"],ￖ:["\u315C","\u3163"],ￗ:"\u3160",ￚ:"\u3161",ￛ:["\u3161","\u3163"],ￜ:"\u3163"};var all=Object.assign({},jamo$1,jamoExtendedA$1,jamoExtendedB$1,halfwidth$1);

  // tries to transform everything into disassembled standard hangul
  var transformChar=function(a){return !standardHangul.contains(a)&&all[a]||a};var transformDatum=function(a){return transformChar(Character(a))};var transformEveryChar=function(a){return (standardHangul.contains(a)?pairs:all)[a]||a};var transformEveryDatum=function(a){return transformEveryChar(Character(a))};// transform everything just means that it also transforms
  // standard hangul characters instead of ignoring them

  var assembleFactory=function(a){return function(b,c){return deepFlatResMap(a(b),composeAnything(c))}};// the transformer should verify that each datum is a Character!
  var assembleTransformer=function(a){return deepMap(a,transformEveryDatum)};// this takes a CharacterGroup and transforms characters and
  // complex characters, effectively leaving behind only the
  // base Characters
  // it doesn't decomposeSyllables though
  var assemble = assembleFactory(assembleTransformer);

  var composeComplexCho=composeComplex(noJungJong);var transformExceptCho=function(a){var b=transformEveryChar(a);if(Array.isArray(b)){var c=composeComplexCho(b);// the default composeComplex only composes cho
  // HACK: this bug might be an issue with composeComplex
  return Array.isArray(c)&&1===c.length?Character(c):c}return b};// this function is needed by disassemble so it's trusting
  var decomposeComplex = (function(a,b){return toArray((b?transformEveryChar:transformExceptCho)(Character(a)))});

  var trustMe=function(a){var b=a.codePointAt(0)-syllables.start,c=b%28,d=(b-c)/28;// basically Math.floor(q / 21)
  return [cho$1[0|d/21],jung$1[d%21],jong$1[c]].filter(function(a){return a});// the .filter(v => v) removes blank space in the array
  };var decomposeSyllable = (function(a,b){var c=Character(a);if(!syllables.contains(c)){if(b)throw Error("Decomposing a syllable requires a syllable to decompose!");return [a];// if there's no hardFail, the function must
  // still return the same type as it would have
  // if it didn't fail
  }return trustMe(c)});

  var disassembleFactory=function(a){return function(b){var c=Character(b);return syllables.contains(c)?trustMe(c).map(a):a(c);// otherwise try breaking complex characters apart
  }};var disassembleAll=disassembleFactory(transformEveryChar),disassemble=disassembleFactory(transformExceptCho);// not to be confused with Hangul.disassemble
  // this disassemble takes Characters as inputs, not CharacterGroups
  var disassembleChar=function(a,b,c){var d=(c?disassembleAll:disassemble)(a);return b?d:flatten(d)};var disassemble$1 = (function(a,b,c){return (b?deepMap:deepFlatMap)(a,c?disassembleAll:disassemble,!0)});// I know this looks really bad since it's all on
  // one line but ESlint was being really finicky

  var name = (function(a){Object.keys(a).forEach(function(b){a[b].displayName=b;});});var nameObject=function(a){var b=Object.keys(a)[0],c=a[b];Object.keys(c).forEach(function(a){c[a].displayName="[".concat(b,".").concat(a,"]");});};

  // This file is only used in ../publicCompose
  // I can't Object.assign them all together unfortunately
  var all$1={ㄱ:{ㄱ:"\u3132",ㅅ:"\u3133"},ㄷ:{ㄷ:"\u3138"},ㅅ:{ㅅ:"\u3146",ㄱ:"\u317A",ㄴ:"\u317B",ㄷ:"\u317C",ㅂ:"\u317D",ㅈ:"\u317E"},ㅈ:{ㅈ:"\u3149"},ㅂ:{ㅂ:"\u3143",ㅅ:{$:"\u3144",ㄱ:"\u3174",ㄷ:"\u3175"},ㄱ:"\u3172",ㄷ:"\u3173",ㅈ:"\u3176",ㅌ:"\u3177"},ㅗ:{ㅏ:"\u3158",ㅐ:"\u3159",ㅣ:"\u315A"},ㅜ:{ㅓ:"\u315D",ㅔ:"\u315E",ㅣ:"\u315F"},ㅡ:{ㅣ:"\u3162"},ㄴ:{ㅈ:"\u3135",ㅎ:"\u3136",ㄴ:"\u3165",ㄷ:"\u3166",ㅅ:"\u3167",ㅿ:"\u3168"},ㄹ:{ㄱ:{$:"\u313A",ㅅ:"\u3169"},ㅁ:"\u313B",ㅂ:{$:"\u313C",ㅅ:"\u316B"},ㅅ:"\u313D",ㅌ:"\u313E",ㅍ:"\u313F",ㅎ:"\u3140",ㄷ:"\u316A",ㅿ:"\u316C",ㆆ:"\u316D"},ㅁ:{ㅂ:"\u316E",ㅅ:"\u316F",ㅿ:"\u3170"},ㅇ:{ㅇ:"\u3180"},ㆁ:{ㅅ:"\u3181",ㅿ:"\u317F"},ㅎ:{ㅎ:"\u3185"},ㅛ:{ㅑ:"\u3187",ㅒ:"\u3188",ㅣ:"\u3189"},ㅠ:{ㅕ:"\u318A",ㅖ:"\u318B",ㅣ:"\u318C"},ㆍ:{ㅣ:"\u318E"}};

  var standardizeCharacterBase=function(a){var b=composeComplex(a);return function(a){var c=transformDatum(a);return Array.isArray(c)?b(c):c}};var standardizeFactory=function(a){var b=standardizeCharacterBase(a);return function(a,c){return (c?deepMap:deepFlatMap)(a,b)}};var standardize = (function(a,b,c){return standardizeFactory(c)(a,b)});

  // standardized so that the libaray can function properly
  var standardizeCharacter=standardizeCharacterBase(useComp3|useArchaic);var complex$1=function(a,b){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"",d=3<arguments.length?arguments[3]:void 0;if(a===void 0||b===void 0)throw Error("Cannot compose a complex with less than two values!");var e=all$1[standardizeCharacter(a)];// depth 1
  if(!e){if(d)throw Error("There's no complex character that starts with ".concat(a));return "".concat(a).concat(b).concat(c)}var f=e[standardizeCharacter(b)];// depth 2
  if(!f){if(d)throw Error("Cannot combine ".concat(a," and ").concat(b));return "".concat(a).concat(b).concat(c)}var g=f.$||f;if(c){// if there's a third character (optional)
  var h=f[standardizeCharacter(c)];// depth 3
  if(!h){// if depth 3 doesn't exist
  if(d)throw Error("Found \"".concat(g,"\" but cannot combine \"").concat(a,"\" and \"").concat(b,"\" with \"").concat(c,"\""));// the reason for this ^^^ is because sometimes
  // d2 is a string rather than an object
  return "".concat(g).concat(c);// at depth three, there should be a complex formed from
  // the first and second characters so return that instead
  // of the inputs concatenated
  }return h;// this should always be a string
  }// the third character was falsy so just return the composition
  return g};// this function will always return a String or it'll error (hardFail)
  // there's probably a better way to structure these if-statements
  // so if anyone comes up with one, I'll take it
  var syllable=function(a){var b,c=Number.isInteger,d=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"",e=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"",f=3<arguments.length?arguments[3]:void 0,g=choNum[standardizeCharacter(a)],h=jungNum[standardizeCharacter(d)];if(e&&(b=jongNum[standardizeCharacter(e)]),!c(g)){if(f)throw Error("\"".concat(a,"\" is not a valid cho Character"));return "".concat(a).concat(d).concat(e)}if(!c(h)){if(f)throw Error("\"".concat(d,"\" is not a valid jung Character"));return "".concat(a).concat(d).concat(e)}if(e&&!c(b)){// check if it exists because !Number.isInteger(undefined)
  // is true and we don't want that happening since jongChar
  // is optional
  if(f)throw Error("\"".concat(e,"\" is not a valid jong character"));// getting here means that the cho and jung
  // characters were valid, so call composeSyllable
  return "".concat(composeSyllableFn(g,h)).concat(e)}return composeSyllableFn(g,h,b)};// by nesting all if-statements under if (hardFail)
  // there might be a little better performance but I'm
  // sure that it's pretty trivial.

  var standardizeComp3Archaic=standardizeFactory(useComp3|useArchaic);// support all types of complex
  var stronger$1 = (function(a){return standardizeComp3Archaic(a).map(function(a){return stronger[a]||a})});

  var hangulToKeyFn=function(a){return hangulToKey[a]||a},transformToKeys=function(a){var b=transformExceptCho(a);return isCharacterGroup(b)?b.split("").map(hangulToKeyFn):hangulToKeyFn(b)},disassembleToKeys=disassembleFactory(transformToKeys);var hangulToKeys=function(a,b){return (b?deepMap:deepFlatMap)(a,disassembleToKeys)};// keystrokes to hangul
  var keyToHangulFn=function(a){return keyToHangul[a]},transformCharToHangul=function(a){var b=Character(a),c=keyToHangulFn(b);if(!c){// couldn't find a key for that characters
  var d=keyToHangulFn(b.toLowerCase());return d?d:b}return c},transformToHangul=function(a){return deepMap(a,transformCharToHangul)},assembleFromKeys=assembleFactory(transformToHangul);var keysToHangul=function(a){return assembleFromKeys(a,noDouble)};// it's okay that we're not standarizing because the data
  // in hangulToKey is already standard :)

  var testMulti = (function(a){return function(b){return function(c){return deepFlatMap(c,transformEveryDatum)[a](b)}}});

  var contains = testMulti("some");

  var is = (function(a){return function(b){var c=transformEveryDatum(b);// it's okay that we don't check if data is
  // a Character since transformEveryCharacter does.
  return Array.isArray(c)?c.every(a):a(c)}});

  var isAll = testMulti("every");

  var consonant=function(a){return consonants[a]};var isConsonant=is(consonant);var isConsonantAll=isAll(consonant);var containsConsonant=contains(consonant);

  var isAll$1=function(a){return function(b){var c=b.length;if(Array.isArray(b)){for(var d,e=0;e<c;e++)if(d=b[e],isCharacterGroup(d)?!isAll$1(a)(d):!a(d))// the loop will get here if it doesn't satisfy the testing function
  return !1;return !0}if("string"==typeof b){for(var f,g=0;g<c;g++)if(f=b[g],!a(f))return !1;return !0}throw TypeError("The data must be an Array or a String!")}};var contains$1=function(a){return function(b){var c=b.length;if(Array.isArray(b)){for(var d,e=0;e<c;e++)if(d=b[e],isCharacterGroup(d)?isAll$1(a)(d):a(d))return !0;// this allows the function to short circut
  return !1}if("string"==typeof b){for(var f,g=0;g<c;g++)if(f=b[g],a(f))return !0;return !1}throw TypeError("The data must be an Array or a String!")}};

  var isFactory=function(a){return function(b){return blocks[a].conains(Character(b))}};var is$1={jamo:isFactory("jamo"),compatibilityJamo:isFactory("compatibilityJamo"),jamoExtendedA:isFactory("jamoExtendedA"),syllable:isFactory("syllable"),jamoExtendedB:isFactory("jamoExtendedB"),halfwidth:isFactory("halfwidth"),reserved:isFactory("reserved"),standardHangul:isFactory("standardHangul"),hangul:isFactory("hangul")};var isAll$2={jamo:isAll$1(is$1.jamo),compatibilityJamo:isAll$1(is$1.compatibilityJamo),jamoExtendedA:isAll$1(is$1.jamoExtendedA),syllable:isAll$1(is$1.syllable),jamoExtendedB:isAll$1(is$1.jamoExtendedB),halfwidth:isAll$1(is$1.halfwidth),reserved:isAll$1(is$1.reserved),standardHangul:isAll$1(is$1.standardHangul),hangul:isAll$1(is$1.hangul)};var contains$2={jamo:contains$1(is$1.jamo),compatibilityJamo:contains$1(is$1.compatibilityJamo),jamoExtendedA:contains$1(is$1.jamoExtendedA),syllable:contains$1(is$1.syllable),jamoExtendedB:contains$1(is$1.jamoExtendedB),halfwidth:contains$1(is$1.halfwidth),reserved:contains$1(is$1.reserved),standardHangul:contains$1(is$1.standardHangul),hangul:contains$1(is$1.hangul)};

  var vowel=function(a){return vowels[a]};var isVowel$1=is(vowel);var isVowelAll=isAll(vowel);var containsVowel=contains(vowel);

  is$1.consonant=isConsonant,isAll$2.consonant=isConsonantAll,contains$2.consonant=containsConsonant,is$1.vowel=isVowel$1,isAll$2.vowel=isVowelAll,contains$2.vowel=containsVowel,nameObject({is:is$1}),nameObject({isAll:isAll$2}),nameObject({contains:contains$2});

  name({assemble:assemble,disassemble:disassemble$1,disassembleCharacter:disassembleChar,composeComplex:complex$1,composeSyllable:syllable,stronger:stronger$1});

  exports.assemble = assemble;
  exports.a = assemble;
  exports.disassemble = disassemble$1;
  exports.d = disassemble$1;
  exports.disassembleCharacter = disassembleChar;
  exports.composeComplex = complex$1;
  exports.composeSyllable = syllable;
  exports.stronger = stronger$1;
  exports.useComp3 = useComp3;
  exports.useArchaic = useArchaic;
  exports.noJungJong = noJungJong;
  exports.noDouble = noDouble;
  exports.decomposeComplex = decomposeComplex;
  exports.decomposeSyllable = decomposeSyllable;
  exports.standardize = standardize;
  exports.flatten = flatten;
  exports.deepMap = deepMap;
  exports.hangulToKeys = hangulToKeys;
  exports.keysToHangul = keysToHangul;
  exports.is = is$1;
  exports.isAll = isAll$2;
  exports.contains = contains$2;

  return exports;

}({}));
